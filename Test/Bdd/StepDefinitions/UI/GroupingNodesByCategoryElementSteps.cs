// --------------------------------------------------------------------------------------------------------------------
// <copyright file="GroupingNodesByCategoryElementSteps.cs" company="Microsoft">
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
//    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
//    OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
//    OTHER DEALINGS IN THE SOFTWARE.
// </copyright>
//<autogenerated>
// --------------------------------------------------------------------------------------------------------------------
namespace Ecp.True.Bdd.Tests.StepDefinitions
{
    using System.Threading.Tasks;

    using Ecp.True.Bdd.Tests.Entities;
    using Ecp.True.Bdd.Tests.Properties;
    using Ecp.True.Bdd.Tests.StepDefinitions.UI;
    using Ecp.True.Bdd.Tests.Utils;

    using global::Bdd.Core.Web.Executors;
    using global::Bdd.Core.Web.Utils;

    using NUnit.Framework;

    using Ocaramba.Types;

    using TechTalk.SpecFlow;

    [Binding]
    public class GroupingNodesByCategoryElementSteps : EcpWebStepDefinitionBase
    {

        [When(@"I select required Nodes from ""(.*)"" ""(.*)""")]
        public void WhenISelectRequiredNodesFrom(string p0, string p1)
        {
            this.Get<ElementPage>().Click(nameof(Resources.NodeCheckBox));
        }

        [When(@"I select required Date (from "".*"" "".*"")")]
        public void WhenISelectRequiredDateFrom(ElementLocator elementLocator)
        {
            this.ISelectRequiredDateFrom(elementLocator);
        }

        [When(@"I select value from ""(.*)"" dropdown")]
        public async System.Threading.Tasks.Task WhenISelectValueFromDropdownAsync(string field)
        {
            var lastCreatedElement = await this.ReadSqlAsStringDictionaryAsync(field.Equals(ConstantValues.Category) ? SqlQueries.GetLastCategory : SqlQueries.GetElementByCategory).ConfigureAwait(false);
            string fieldValue = lastCreatedElement[ConstantValues.Name];
            this.Get<ElementPage>().Click(nameof(Resources.SelectBox), formatArgs: UIContent.Conversion[field]);
            this.Get<ElementPage>().WaitUntilElementToBeClickable(nameof(Resources.SelectBoxMenu), 5, formatArgs: UIContent.Conversion[field]);
            this.Get<ElementPage>().Click(nameof(Resources.SelectBoxOption), formatArgs: fieldValue);
        }

        [When(@"I select ""(.*)"" from NodeTags ""(.*)"" dropdown ""(.*)""")]
        public void WhenISelectFromNodeTagsDropdown(string value, string type, string number)
        {
            this.ISelectFromNodeTagsDropdown(value, type, number);
        }


        [When(@"I search for existing ""(.*)"" record using filter")]
        public async Task WhenISearchForExisitngRecordUsingFilterAsync(string entity)
        {
            var fieldValue = string.Empty;
            if (entity.Equals(ConstantValues.Node))
            {
                var lastCreatedNode = await this.ReadSqlAsStringDictionaryAsync(SqlQueries.GetLastNode).ConfigureAwait(false);
                fieldValue = lastCreatedNode[ConstantValues.Name];
                this.Get<ElementPage>().GetElement(nameof(Resources.NodeNameFilter)).SendKeys(fieldValue);
                this.Get<ElementPage>().GetElement(nameof(Resources.NodeNameFilter)).SendKeys(OpenQA.Selenium.Keys.Enter);
            }
            else if (entity.Contains(ConstantValues.Category))
            {
                var lastCreatedCategory = await this.ReadSqlAsStringDictionaryAsync(entity.Equals(ConstantValues.Category) ? SqlQueries.GetLastCategory : SqlQueries.GetLastCategoryElement).ConfigureAwait(false);
                fieldValue = lastCreatedCategory[ConstantValues.Name];
                this.SetValue(Entities.Keys.Result, fieldValue);
                this.Get<ElementPage>().GetElement(entity.Equals(ConstantValues.Category) ? nameof(Resources.CategoryNameFilter) : nameof(Resources.ElementNameFilter)).SendKeys(fieldValue);
                this.Get<ElementPage>().GetElement(entity.Equals(ConstantValues.Category) ? nameof(Resources.CategoryNameFilter) : nameof(Resources.ElementNameFilter)).SendKeys(OpenQA.Selenium.Keys.Enter);
            }
            else
            {
                this.Get<ElementPage>().GetElement(nameof(Resources.ElementNameFilter)).SendKeys(this.GetValue(entity + "Name"));
                this.Get<ElementPage>().GetElement(nameof(Resources.ElementNameFilter)).SendKeys(OpenQA.Selenium.Keys.Enter);
            }
            await Task.Delay(10000).ConfigureAwait(false);
        }

        [When(@"I select new ""(.*)"" from dropdown")]
        public void WhenISelectNewFromDropdown(string value)
        {
            this.Get<ElementPage>().WaitUntilInvisibilityOfElementLocated(nameof(Resources.Loader));
            Assert.IsNotNull(value);
        }

        [When(@"I select new Element from ""(.*)"" ""(.*)""")]
        public void WhenISelectNewElementFrom(string p0, string p1)
        {
            ScenarioContext.Current.Pending();
        }

        [When(@"I select from ""(.*)"" ""(.*)""")]
        public void WhenISelectFrom(string p0, string p1)
        {
            ScenarioContext.Current.Pending();
        }

        [Then(@"I should see the new Nodes grouped based on the chosen Category Element")]
        public async Task ThenIShouldSeeTheNewNodesGroupedBasedOnTheChosenCategoryElementAsync()
        {
            var newNodeTag = await this.ReadSqlAsStringDictionaryAsync(SqlQueries.GetNewNodeTag, args: new { nodeId = this.GetValue("NodeId") }).ConfigureAwait(false);
            Assert.IsNotNull(newNodeTag);
        }

        [Then(@"the end date of new groupings should be maximum date")]
        public async Task ThenTheEndDateOfnewGroupingsShouldBeMaximumDateAsync()
        {
            var newNodeTag = await this.ReadSqlAsStringDictionaryAsync(SqlQueries.GetNewNodeTag, args: new { nodeId = this.GetValue("NodeId") }).ConfigureAwait(false);
            Assert.AreEqual(ConstantValues.MaxDate, newNodeTag["EndDate"]);
        }

        [Then(@"the life time range of Nodes to the Category Element should be changed")]
        public async Task ThenTheLifeTimeRangeOfNodesToTheCategoryElementShouldBeChangedAsync()
        {
            var newNodeTag = await this.ReadSqlAsStringDictionaryAsync(SqlQueries.GetNewNodeTag, args: new { nodeId = this.GetValue("NodeId") }).ConfigureAwait(false);
            Assert.AreEqual(this.GetValue("FutureDate"), newNodeTag["EndDate"].Replace(" ", string.Empty));
        }

        [Then(@"I should see the list of all Nodes in the system")]
        public void ThenIShouldSeeTheListOfAllNodesInTheSystem()
        {
            ScenarioContext.Current.Pending();
        }

        [Then(@"the checkbox should be preselected for the Nodes in the Category Element with current association")]
        public void ThenTheCheckboxShouldBePreselectedForTheNodesInTheCategoryElementWithCurrentAssociation()
        {
            ScenarioContext.Current.Pending();
        }

        [Then(@"the end date should be indefinite for the Nodes in the Category Element with current association")]
        public void ThenTheEndDateShouldBeIndefiniteForTheNodesInTheCategoryElementWithCurrentAssociation()
        {
            ScenarioContext.Current.Pending();
        }

        [Then(@"the selection should be disabeld")]
        public void ThenTheSelectionShouldBeDisabeld()
        {
            ScenarioContext.Current.Pending();
        }

        [Then(@"I should not allow to uncheck")]
        public void ThenIShouldNotAllowToUncheck()
        {
            ScenarioContext.Current.Pending();
        }

        [Then(@"I should see that the effective date of the associated nodes is equal or greater than the current date")]
        public void ThenIShouldSeeThatTheEffectiveDateOfTheAssociatedNodesIsEqualOrGreaterThanTheCurrentDate()
        {
            ScenarioContext.Current.Pending();
        }

        [Then(@"the checkbox should be preselected for the Nodes in the Category Element in the first filter")]
        public void ThenTheCheckboxShouldBePreselectedForTheNodesInTheCategoryElementInTheFirstFilter()
        {
            ScenarioContext.Current.Pending();
        }

        [Then(@"the nodes that will be preselected and disabled for the match in the first filter")]
        public void ThenTheNodesThatWillBePreselectedAndDisabledForTheMatchInTheFirstFilter()
        {
            ScenarioContext.Current.Pending();
        }

        [Then(@"And I should see that the effective date of the associated nodes is equal or greater than the current date")]
        public void ThenAndIShouldSeeThatTheEffectiveDateOfTheAssociatedNodesIsEqualOrGreaterThanTheCurrentDate()
        {
            ScenarioContext.Current.Pending();
        }

        [Then(@"I should be able to select the new Nodes for grouping that match with second or third filter")]
        public void ThenIShouldBeAbleToSelectTheNewNodesForGroupingThatMatchWithSecondOrThirdFilter()
        {
            ScenarioContext.Current.Pending();
        }

        [Then(@"I should see the future due dates for the Nodes")]
        public void ThenIShouldSeeTheFutureDueDatesForTheNodes()
        {
            ScenarioContext.Current.Pending();
        }
    }
}
