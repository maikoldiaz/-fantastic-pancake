// --------------------------------------------------------------------------------------------------------------------
// <copyright file="Communicator.cs" company="Microsoft">
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
//    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
//    OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
//    OTHER DEALINGS IN THE SOFTWARE.
// </copyright>
// --------------------------------------------------------------------------------------------------------------------
// <auto-generated>

namespace Ecp.True.Processors.Api
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Linq;
    using System.Threading;
    using System.Threading.Tasks;
    using Ecp.True.Configuration;
    using Ecp.True.Core;
    using Ecp.True.DataAccess.Interfaces;
    using Ecp.True.Entities.Dto;
    using Ecp.True.Entities.Enumeration;
    using Ecp.True.Entities.Registration;
    using Ecp.True.Processors.Api.Interfaces;
    using Ecp.True.Processors.Core;
    using Ecp.True.Processors.Core.Interfaces;
    using Ecp.True.Proxies.Azure;

    /// <summary>
    /// Communication client for balance processor.
    /// </summary>
    public class Communicator : ICommunicator
    {
        /// <summary>
        /// The azure client factory.
        /// </summary>
        private readonly IAzureClientFactory azureClientFactory;

        /// <summary>
        /// The configuration handler.
        /// </summary>
        private readonly IConfigurationHandler configurationHandler;

        /// <summary>
        /// The unit of work factory.
        /// </summary>
        private readonly IUnitOfWorkFactory unitOfWorkFactory;
        private readonly IRegistrationStrategyFactory registrationStrategyFactory;

        /// <summary>
        /// Initializes a new instance of the <see cref="Communicator" /> class.
        /// </summary>
        /// <param name="azureClientFactory">The azure client factory.</param>
        /// <param name="configurationHandler">The configuration handler.</param>
        /// <param name="unitOfWorkFactory">The unit of work factory.</param>
        /// <param name="registrationStrategyFactory">The registration strategy factory.</param>
        public Communicator(
            IAzureClientFactory azureClientFactory,
            IConfigurationHandler configurationHandler,
            IUnitOfWorkFactory unitOfWorkFactory,
            IRegistrationStrategyFactory registrationStrategyFactory)
        {
            this.azureClientFactory = azureClientFactory;
            this.configurationHandler = configurationHandler;
            this.unitOfWorkFactory = unitOfWorkFactory;
            this.registrationStrategyFactory = registrationStrategyFactory;
        }

        /// <inheritdoc />
        public async Task RegisterOwnerShipAsync(PublishedNodeOwnership nodeOwnership)
        {
            ArgumentValidators.ThrowIfNull(nodeOwnership, nameof(nodeOwnership));
            var unitOfWork = this.unitOfWorkFactory.GetUnitOfWork();
            this.UpdateMovementOwnershipExecutionDate(nodeOwnership.Movements);
            var newMovements = nodeOwnership.Movements.Where(x => x.MovementTransactionId < 0 && x.EventType.EqualsIgnoreCase(Constants.Insert)).ToList();
            var contractIdList = nodeOwnership.Movements.Select(y => y.MovementContractId).Distinct();
            var contractRepository = unitOfWork.CreateRepository<Contract>();
            var contracts = await contractRepository.GetAllAsync(x => contractIdList.Contains(x.ContractId)).ConfigureAwait(false);

            foreach (var newMovement in newMovements)
            {
                this.PopulateMovement(newMovement, nodeOwnership.TicketId);
                var contract = contracts.FirstOrDefault(x => x.ContractId == newMovement.MovementContractId);
                if (contract != null)
                {
                    newMovement.MovementContract = contract.ToMovementContractData();
                }
            }
            var updatedMovements = nodeOwnership.Movements.Where(x => x.MovementTransactionId > 0 && !x.EventType.EqualsIgnoreCase(Constants.Insert)).ToList();
            var updatedInventoryOwnerships = nodeOwnership.InventoryOwnerships.Select(x => x.Ownership);
            var updateMovementTransactionIds = updatedMovements.Select(y => y.MovementTransactionId);

            this.registrationStrategyFactory.MovementRegistrationStrategy.Insert(newMovements, unitOfWork);
            var movementContractRepository = unitOfWork.CreateRepository<MovementContract>();
            var movementRepository = unitOfWork.CreateRepository<Movement>();
            var movements = await movementRepository.GetAllAsync(x => updateMovementTransactionIds.Contains(x.MovementTransactionId)).ConfigureAwait(false);
            foreach (var updatedMovement in updatedMovements)
            {
                await this.registrationStrategyFactory.OwnershipRegistrationStrategy.RegisterAsync(updatedMovement, unitOfWork).ConfigureAwait(false);

                var movement = movements.Where(x => x.MovementTransactionId == updatedMovement.MovementTransactionId).FirstOrDefault();
                if (movement != null)
                {
                    if (movement.MovementContractId != updatedMovement.MovementContractId)
                    {
                        if (movement.MovementContractId != null)
                        {
                            var deletedMovementContract = await movementContractRepository.GetByIdAsync(movement.MovementContractId).ConfigureAwait(false);
                            deletedMovementContract.IsDeleted = true;
                            movementContractRepository.Update(deletedMovementContract);
                        }

                        var contract = contracts.FirstOrDefault(x => x.ContractId == updatedMovement.MovementContractId);
                        var movementContract = contract.ToMovementContractData();
                        movement.MovementContract = movementContract;
                    }

                    movement.ReasonId = updatedMovement.ReasonId;
                    movement.Comment = updatedMovement.Comment;
                    movementRepository.Update(movement);
                }
            }

            foreach (var editOwnershipInfo in nodeOwnership.InventoryOwnerships)
            {
                await this.registrationStrategyFactory.OwnershipRegistrationStrategy.RegisterAsync(editOwnershipInfo.Ownership, unitOfWork).ConfigureAwait(false);

                var inventoryProductRepository = unitOfWork.CreateRepository<InventoryProduct>();
                var inventoryProduct = await inventoryProductRepository.
                    FirstOrDefaultAsync(x => x.InventoryProductId == editOwnershipInfo.Ownership.InventoryProductId).ConfigureAwait(false);
                inventoryProduct.ReasonId = editOwnershipInfo.ReasonId;
                inventoryProduct.Comment = editOwnershipInfo.Comment;
                inventoryProductRepository.Update(inventoryProduct);
            }

            await unitOfWork.SaveAsync(CancellationToken.None).ConfigureAwait(false);

            await this.SendToQueueAsync(new RecalculateOwnershipMessage(nodeOwnership.OwnershipNodeId, nodeOwnership.HasDeletedMovementOwnerships)).ConfigureAwait(false);
        }

        private void UpdateMovementOwnershipExecutionDate(IEnumerable<Movement> movements)
        {
            movements.ForEach(m => m.Ownerships.ForEach(x => x.ExecutionDate = DateTime.Now.ToTrue()));
        }

        private void PopulateMovement(Movement movement, int ticketId)
        {
            movement.MovementTransactionId = 0;
            movement.MovementId = Convert.ToString(DateTime.UtcNow.ToTrue().Ticks, CultureInfo.InvariantCulture);
            movement.MessageTypeId = this.GetMessageTypeId(movement.VariableTypeId);
            movement.SystemTypeId = 1;
            movement.EventType = EventType.Insert.ToString();
            movement.GrossStandardVolume = null;
            movement.UncertaintyPercentage = null;
            movement.Observations = string.Empty;
            movement.IsDeleted = false;
            movement.FileRegistrationTransactionId = null;
            movement.BlockchainMovementTransactionId = Guid.NewGuid();
            movement.OwnershipTicketId = ticketId;
            movement.SourceSystemId = (int)SourceSystem.TRUE;
        }

        private int GetMessageTypeId(VariableType? variableTypeId)
        {
            int messageTypeId = 1;

            if (variableTypeId.HasValue)
            {
                if (variableTypeId == VariableType.Input || variableTypeId == VariableType.Output)
                {
                    messageTypeId = 1;
                }
                else if (variableTypeId == VariableType.IdentifiedLosses)
                {
                    messageTypeId = 2;
                }
                else
                {
                    messageTypeId = 3;
                }
            }

            return messageTypeId;
        }

        /// <summary>
        /// Pushes the message to given queue.
        /// </summary>
        /// <param name="recalculateOwnershipMessage">The recalculate ownership message.</param>
        private async Task SendToQueueAsync(RecalculateOwnershipMessage recalculateOwnershipMessage)
        {
            var reCalculationQueueClient = this.azureClientFactory.GetQueueClient(Constants.ReCalculationQueue);

            await reCalculationQueueClient.QueueMessageAsync(recalculateOwnershipMessage).ConfigureAwait(false);
        }
    }
}
